#!/usr/bin/env python

"""
moku-wiki

Convert page links into Markdown links, using slugified name. For example

	This is a link to [[Some Other Page]] with stuff

becomes

	This is a link to [Some Other Page](some_other_page.html) with stuff

Also inserts a level 1 heading using the title of the page (from the metadata) and renames the output file to the slugified title (to ensure consistency).

TODO

The script is furiously bereft of error checking (name conflicts etc)
"""

import os
import re
import sys

###

def create_tag_index():

	for file in os.listdir(source):

		with open( os.path.join(source, file), "r" ) as input_file:
			contents = input_file.read()

		title = regex_meta_title.search(contents)

		if not title:
			continue
		else:
			title = title.group(1).strip()

		tags = regex_meta_tags.search(contents)

		if not tags:
			continue
		else:
			# if there are tags remove spaces and brackets then split into list
			tags = tags.group(1).translate(None, ' []').split(",")

		# add each tag to index, with titles as set
		for tag in tags:
			if tag not in index_tags:
				index_tags[tag] = list()
			index_tags[tag].append(title)

###

def convert_page_link(page):
	link_name = str(page.group())[2:-2]
	file_name = ""

	if "|" in link_name:
		link_name, file_name = link_name.split("|")

	if not file_name:
		file_name = create_valid_filename(link_name)

	# TODO if page does not exist in index then turn into bracketed span with class='broken'

	print "convert " + link_name

	if search_index_title(file_name):
		return "[" + link_name + "](" + file_name + ".html)"
	else:
		return "[" + link_name + "]{.broken}"

###

def search_index_title(title):
	for key, value in index_tags.items():
		for v in value:
			if title in create_valid_filename(v):
				return True

	return False

###

def convert_tag_link(tags):
	tag_list = str(tags.group())[2:-2]
	tag_list = tag_list.split(" ")

	# get initial category
	page_set = set(index_tags[tag_list[0]])

	# add other categories
	for i, tag in enumerate(tag_list[1:]):
		tag_val = tag

		if tag[0] == '+' or tag[0] == '-':
			tag_val = tag[1:]

		if tag_val not in index_tags:
			continue

		if tag[0] == '+':
			page_set = page_set & set(index_tags[tag_val])
		elif tag[0] == '-':
			page_set = page_set - set(index_tags[tag_val])
		else:
			page_set = page_set | set(index_tags[tag_val])

	page_list = ""

	for page in sorted(list(page_set)):
		page_list += "[[" + page + "]]\n\n"

	return page_list

###

def create_valid_filename(s):
	# see also https://stackoverflow.com/questions/295135/turn-a-string-into-a-valid-filename
	# re: Django comment about removing unicode chars
	return s.strip().replace(' ', '_').lower()

### MAIN ###

regex_page_link = re.compile(r"\[\[.*\]\]")
regex_tags_link = re.compile(r"\{\{.*\}\}")
regex_meta_title = re.compile(r"[T|t]itle:(.*)(\r\n|\r|\n)")
regex_meta_tags = re.compile(r"[T|t]ags:(.*)(\r\n|\r|\n)")
regex_yaml_end = re.compile(r"\.\.\.(\r\n|\r|\n)")

if len(sys.argv) != 3:
	print "usage: " + sys.argv[0] + " source_dir target_dir"
	exit()

source = sys.argv[1]
target = sys.argv[2]

index_tags = {}

# create index

create_tag_index()

# process files

for file in os.listdir(source):

	with open( os.path.join(source, file), "r" ) as input_file:
		contents = input_file.read()

	# TODO need to check each of these for None
	title = regex_meta_title.search(contents)

	if not title:
		print sys.argv[0] + ": skipping '" + file + "', no title found"
		continue
	else:
		title = title.group(1).strip()

	# add header (assumes first ... ends YAML block)
	### NOTE may not need this if we use the right template
	contents = contents.replace("...\n", "...\n\n# " + title + "\n", 1)

	# replace tags links - use create_page_links() function to create paras from index, use [[ ]] format
	contents = regex_tags_link.sub(convert_tag_link, contents)

	# replace page links
	contents = regex_page_link.sub(convert_page_link, contents)

	# get new file name by adding ".md" to title
	title = create_valid_filename(title) + ".md"

	with open( os.path.join(target, title), "w" ) as output_file:
		output_file.write(contents)
