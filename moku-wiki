#!/usr/bin/env python

"""
moku-wiki

Convert page links into Markdown links, using slugified name. For example

	This is a link to [[Some Other Page]] with stuff

becomes

	This is a link to [Some Other Page](some_other_page.html) with stuff

Also inserts a level 1 heading using the title of the page (from the metadata) and renames the output file to the slugified title (to ensure consistency).

TODO

The script is furiously bereft of error checking (name conflicts etc)
"""

import os
import re
import sys

###

def create_tag_index():

	for file in os.listdir(source):

		if file.startswith("."):
			continue

		with open( os.path.join(source, file), "r" ) as input_file:
			contents = input_file.read()

		title = regex_meta_title.search(contents)

		if not title:
			continue
		else:
			title = title.group(1).strip()

		tags = regex_meta_tags.search(contents)

		if not tags:
			continue
		else:
			# if there are tags remove spaces and brackets then split into list
			tags = tags.group(1).translate(None, ' []').split(",")

		# add each tag to index, with titles as set
		for tag in tags:
			if tag not in index_tags:
				index_tags[tag] = list()
			index_tags[tag].append(title)

###

def convert_page_link(page):
	link_name = str(page.group())[2:-2]
	file_name = ""

	if "|" in link_name:
		link_name, file_name = link_name.split("|")

	if not file_name:
		# if no file_name supplied, make one from link_name
		file_name = create_valid_filename(link_name)
	else:
		# otherwise make sure file_name is valid
		file_name = create_valid_filename(file_name)

	# make link
	if search_index_title(file_name):
		return "[" + link_name + "](" + file_name + ".html)"
	else:
		# if page does not exist in index then turn into bracketed span with class='broken'
		return "[" + link_name + "]{.broken}"

###

def search_index_title(title):
	for key, value in index_tags.items():
		for v in value:
			# TODO should cache filename and title in index, ALSO should be = not in
			## then could also check for slugified name conflicts
			## moku_index would be a dict with key "tags" and value is dictionary, then also has key "title" with value file_name
			## then index_tags calls would be moku_index["tags"]
			## for JS search function could also change this into "page" "strings" (which contains tokens from title)
			## but would still need title to make the page name 
			if title in create_valid_filename(v):
				return True

	return False

###

def convert_tag_link(tags):
	tag_list = str(tags.group())[2:-2]
	tag_list = tag_list.split(" ")

	# get initial category
	tag_val = tag_list[0]
	page_contents = ""

	# if the first tag is "*" then list all pages, sorted. the comprehension flattens the lists of lists
	if "*" in tag_val:

		for page in sorted(list( set( [item for lst in index_tags.values() for item in lst ]) )):
			page_contents += "[[" + page + "]]\n\n"

		return page_contents

	# continue if not showing all pages
	if tag_val not in index_tags:
		return

	page_set = set(index_tags[tag_list[0]])

	# add other categories
	for i, tag in enumerate(tag_list[1:]):

		if tag[0] == '+' or tag[0] == '-':
			tag_val = tag[1:]

		if tag_val not in index_tags:
			continue

		if tag[0] == '+':
			page_set = page_set & set(index_tags[tag_val])
		elif tag[0] == '-':
			page_set = page_set - set(index_tags[tag_val])
		else:
			page_set = page_set | set(index_tags[tag_val])

	for page in sorted(list(page_set)):
		page_contents += "[[" + page + "]]\n\n"

	return page_contents

###

def create_valid_filename(s):
	# see also https://stackoverflow.com/questions/295135/turn-a-string-into-a-valid-filename
	# re: Django comment about removing unicode chars
	s = str(s).strip().replace(' ', '_').lower()
	return re.sub(r'(?u)[^-\w.]', '', s)

### MAIN ###

regex_page_link = re.compile(r"\[\[[\w\s,|']*\]\]")
regex_tags_link = re.compile(r"\{\{[\w\s\*+-]*\}\}")
regex_meta_title = re.compile(r"[T|t]itle:(.*)(\r\n|\r|\n)")
regex_meta_tags = re.compile(r"[T|t]ags:(.*)(\r\n|\r|\n)")
# regex_yaml_end = re.compile(r"\.\.\.(\r\n|\r|\n)")

if len(sys.argv) != 3:
	print "usage: " + sys.argv[0] + " source_dir target_dir"
	exit()

source = sys.argv[1]
target = sys.argv[2]

index_tags = {}

# create index

create_tag_index()

# process files

for file in os.listdir(source):

	if file.startswith("."):
		continue

	with open( os.path.join(source, file), "r" ) as input_file:
		contents = input_file.read()

	# TODO need to check each of these for None
	title = regex_meta_title.search(contents)

	if not title:
		print sys.argv[0] + ": skipping '" + file + "', no title found"
		continue
	else:
		title = title.group(1).strip()

	### TODO if tags is NOT bracketed then put brackets around them so pandoc can iterate over them as a YAML sequence?

	# add header (assumes first ... ends YAML block)
	### NOTE may not need this if we use the right template
	#contents = contents.replace("...\n", "...\n\n# " + title + "\n", 1)

	# replace tags links - use create_page_links() function to create paras from index, use [[ ]] format
	contents = regex_tags_link.sub(convert_tag_link, contents)

	# replace page links
	contents = regex_page_link.sub(convert_page_link, contents)

	# get new file name by adding ".md" to title
	title = create_valid_filename(title) + ".md"

	with open( os.path.join(target, title), "w" ) as output_file:
		output_file.write(contents)
